# Part1-2 作业

( 请在当前文件直接作答 )

## 简答题

### 1. 请说出下列最终执行结果，并解释为什么?

```javascript
var a = [];
for(var i = 0; i < 10; i++) {
  a[i] = function() {
    console.log(i)
  }
}
a[6]()
```
结果为输出10
因为var定义的变量没有块级作用域，他会被挂载到全局上下文中，当循环执行到最后一次结束时，此时i的值时10.
当执行函数时，发现当前上下文没有变量i，他会向上查找，它的上级作用域是全局上下文，全局上下文中有变量i=10。因此输出10

要想避免这个问题，可以使用let声明变量，let会形成块级上下文；还可以利用闭包保存的机制避免这个问题。

### 2. 请说出此案列最终执行结果，并解释为什么?

```javascript
var tmp = 123;
if (true) {
  console.log(tmp);
  let tmp;
}
```
输出123
因为if判断会形成块级作用域，在这个作用域中用let声明了一个和全局上下文相同的变量，不会影响全局上下文。
　

　

### 3. 结合ES6语法，用最简单的方式找出数组中的最小值

```javascript
var arr = [12, 34, 32, 89, 4]
```
Math.min(...arr)
　

　

### 4. 请详细说明var、let、const三种声明变量的方式之间的具体差别
var声明的变量会在词法解析阶段进行变量提升，导致我们可以在变量声明之前也可以使用；
在全局上下文中声明的变量会被添加到全局对象（GO）中，例如：var a = 10; console.log(window.a) // 10

let解决var变量提升的问题；let声明的变量会形成块级上下文；let声明的变量不能在声明之前使用。

const没有变量提升；const声明变量会创建一个只读引用，一旦声明不允许改变地址；它声明的引用对象的值可以被改变，但是变量指向的堆地址不能改变。

　

### 5. 请说出下列代码最终输出结果，并解释为什么？

```javascript
var a = 10;
var obj = {
  a: 20,
  fn() {
    setTimeout(() => {
      console.log(this.a)
    })
  }
}
obj.fn()
```
输出20
调用obj.fn()，此时函数内部this执行obj
随后创建一个定时器，并传递了一个箭头函数，因为箭头函数没有上下文(this)，箭头函数内部调用this，会在他的上级作用域中查找(fn), 此时this执行obj
因为obj.a为20，输出20

　

### 6. 简述Symbol类型的用途
- 我们在使用第三方模块时，想要对其扩展，由于我们不知道内部具体定义的哪些属性，在这种情况下，去为其扩展属性，就会很大可能发生冲突的问题。那么使用Symbol作为属性就不会出现这种问题。
- 可以为对象添加私有属性
```
const name = Symbol()
class Person {
  [name]: "xsl",
    say(){
    // 只能通过这种方式访问
    console.log(this.[name])
  }
}
// 而当我们在外部使用时，由于不知道内部的唯一键是什么，因此只能通过实例间接访问，而无法在外部直接访问。
const obj = new Person()
console. log(obj.say)
```
- Symbol提供了很多内置常量，用于作为内部方法的标识。这些标识符可以让自定义对象实现JS当中内置的接口。
```
const obj = {
  [Symbol.toStringTag]: "XObject"
}
console.log(obj.toString()) // [ object XObject]
```

　

### 7. 说说什么是浅拷贝，什么是深拷贝？
浅拷贝只是对变量对应的引用拷贝；深拷贝会对变量对应的堆进行拷贝。
由于浅拷贝只是浅层复制引用，只深拷贝第一层的基本类型，当对新拷贝的引用类型的值进行修改，会影响原有的变量。
深拷贝其实是对引用类型递归拷贝值，因此深拷贝出来的的是一份全新的变量，他会创建新的堆内存空间，对新的修改不会影响原来的值。　

　

### 8. 请简述TypeScript与JavaScript之间的关系？
TypeScript是JavaScript的超集。TypeScript在JavaScript基础上增加了强类型系统和新的E6+特性，它是一门全新的语言。
TypeScript会被编译成JavaScript。
　

　

### 9. 请谈谈你所认为的typescript优缺点
优点：
- TypeScript增加了代码的可读性和可维护性
- TypeScript是渐进式的，即使我们对TypeScript不是很熟悉，也可以“学到哪用到哪”。
缺点：
- 对于短期项目会增加项目开发成本，因为要多写一些类型定义；但是对于长期维护的项目，TypeScript能减少项目维护成本。
- 有一定的学习成本，需要理解接口（Interfaces）、泛型（Generics）、类（Classes）、枚举类型（Enums）等前端工程师可能不是很熟悉的概念。
　

　

### 10. 描述引用计数的工作原理和优缺点
核心思想：内部通过一个计数器来维护当前对象的引用数，从而判断当前对象的引用数是否为0，来决定它是不是一个垃圾对象。当这个对象的引用为0的时候，GC就开始工作，将其所在的对象空间进行回收和释放，然后再使用。

当某个对象的引用关系发生改变时，引用计数器就会主动去修改当前对象所对应的引用数值。当引用为0时，GC就会将其所在的空间回收。

引用关系发生改变：假设我们的代码里面有一个对象空间，如果有一个变量名指向它，这时就把对象空间的引用加1，如果又有一个变量指向它，那就再加1；如果是减少的情况，例如取消引用，那就减1。为0时，GC就会立即将其回收。

#### 引用计数算法的优缺点
优点  
- 发现垃圾时立即回收
如果引用为0就会立即进行回收、释放
- 最大限度减少程序暂停
由于引用计数算法会时刻监控着那么引用为0的对象，如果在栈满时，会以最快的速度释放空间。程序就不会因为栈满而停止运行了。  
缺点  
- 无法回收循环引用的对象  
```js
function fn() {
    const obj1 = {}
const obj2 = {}
// 在全局上下文中，没有使用到这两个对象了，他们已经可以被回收了
// 但是由于这两个对象相互循环引用，在使用引用计数算法时，他仍然还是有引用并且不为0，因此GC无法对其回收。
obj1.name = obj2
obj2.name = obj1

return 'ok'
}
fn() // 当函数执行完毕，会释放里面的空间
```
- 时间开销大
  需要时刻监控对象是否修改，如果有很多的对象需要修改，需要的时间就会更久一点

　

### 11. 描述标记整理算法的工作流程
将整个垃圾回收操作分为两个阶段；第一个阶段，遍历所有对象，然后找到这些活动的对象(可达对象)并进行标记，如果不可达就不会标记并且会在第二个阶段被回收掉。第二个阶段，再次遍历所有对象，然后把那些没有被标记的对象进行整理操作，移动对象的位置，并让他们在地址上产生连续。然后再进行清除操作。并把第一阶段中设置的标记抹掉，便于下次GC还能够正常工作。最后就可以把相应的垃圾进行回收，然后再把回收的空间交给空闲链表进行维护，下次程序执行就可以向空闲链表申请空间进行使用。

标记整理算法其实可以看做是标记清除算法的增强版，因为它们在第一个阶段是相同的，都会先遍历所有对象，然后对当前活动对象(可达对象)进行标记操作。

但是不同的是，标记清除算法是直接对没有标记的进行清除，而标记整理算法会在清除之前进行整理操作，移动对象的位置，并让他们在地址上产生连续。

这样连续的可用空间，能够最大化的让程序使用到内存释放出来的空闲空间，避免空间碎片化造成空间浪费。

#### 标记整理算法优缺点
##### 优点
减少碎片化空间：
  因为在第二阶段进行了整理操作，让可用空间地址连续，这样连续的可用空间，能够最大化的让程序使用到内存释放出来的空闲空间，避免空间碎片化造成空间浪费。
##### 缺点
不会立即回收垃圾对象
　

### 12.描述V8中新生代存储区垃圾回收的流程
回收过程采用复制算法+标记整理算法。首先它会将空间分成两个部分(From、To)，而且这两个空间是相同大小的。其中我们将From称为使用空间，将To称为空闲空间。当程序要申请空间时，它会将新申请的活动对象存储于From空间，这个时候To空间是空闲的没有使用。当From使用到一定程度后就会触发GC操作，它将From空间中的活动对象进行标记，然后对空间整理为连续的，便于后续不会产生碎片化空间，这些操作完成后再将这些活动对象拷贝至To空间，From空间里的对象就有一份备份，这就意味着可以对它进行回收，因为活动对象都在To空间里有所体现，所以会直接把From空间中的对象进行回收。
　
#### 回收细节
如果我们在拷贝时，发现某一个变量对象所指向的空间，在我们老生代存储区也存在，这个时候就会发生晋升的现象。这里的晋升指的就是将新生代的对象移动至老生代中进行存储。
判断是否晋升的条件有以下几个：  
- 经过一轮GC还存活的新生代对象需要晋升  
如果新生代中的对象经过一轮GC还存活的，我们就可以把它拷贝至老生代存储区进行存储操作。  
- 在拷贝的过程中，发现To空间的使用率超过25%，也需要把这次的活动对象都移动至老生代存储区中进行存储。  
To空间的使用率如果超过了限制，那么新进来的对象空间好像就存放不进去了，所以在这里有25%的限制操作。
　

### 13. 描述增量标记算法在何时使用及工作原理
当垃圾回收机制工作的时候，是会阻塞我们的程序运行的，程序执行完成后，会暂停下来进行回收操作。标记增量其实就是将一整段的垃圾回收操作拆分成多个小步骤组合着去完成，从而替换掉我们之前一口气去做完的垃圾回收操作。这样做的好处是可以让程序和垃圾回收机制交替着去执行，而不是执行程序时不能进行垃圾回收，垃圾回收时不能执行程序，这样带来的时间消耗也是非常合理的。而且GC执行的效率非常快，给用户带来的体验也更加友好了。
　

　